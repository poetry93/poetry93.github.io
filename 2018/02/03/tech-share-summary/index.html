<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>年终技术分享总结 | Poetry&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、JS应用领域、ES6特性1.1 JavaScript的应用领域 首先很遗憾的一点是，“PHP虽然是最好的语言”，但是它不是最流行的语言   我们先来看一下2017年GitHub上最流行的15种编程语言排行榜 这个数据是 GitHub 根据过去 12 月提交的PR 数量来排名的，虽然不完全准确，但是 PR起码代表了项目的热度与欢迎度   1.1.1 数据可视化 以Processing作为可视化的">
<meta name="keywords" content="总结,思考">
<meta property="og:type" content="article">
<meta property="og:title" content="年终技术分享总结">
<meta property="og:url" content="http://life.poetries.top/2018/02/03/tech-share-summary/index.html">
<meta property="og:site_name" content="Poetry&#39;s Blog">
<meta property="og:description" content="一、JS应用领域、ES6特性1.1 JavaScript的应用领域 首先很遗憾的一点是，“PHP虽然是最好的语言”，但是它不是最流行的语言   我们先来看一下2017年GitHub上最流行的15种编程语言排行榜 这个数据是 GitHub 根据过去 12 月提交的PR 数量来排名的，虽然不完全准确，但是 PR起码代表了项目的热度与欢迎度   1.1.1 数据可视化 以Processing作为可视化的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/rank.jpeg">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/Cordova.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/ionic.jpg">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/react-native.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/mean.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/slack.jpg">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/html5-games.jpg">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/threejs-oculus.jpeg">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/ar.jpg">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/iotjs.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/lot.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/firefox-os.jpg">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/es.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/web1.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/mvc.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/web2.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/spa.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/mvvm.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/node.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/build.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/trend.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/view.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/life1.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/crm.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/dom.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/select-dom.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/add-dom.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/per.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/dd-co.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/performance.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/render.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/local.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/indexDB.jpg">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/cookie.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/worker.png">
<meta property="og:image" content="http://7xq6al.com1.z0.glb.clouddn.com/server-worker.png">
<meta property="og:updated_time" content="2018-02-11T04:28:24.412Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="年终技术分享总结">
<meta name="twitter:description" content="一、JS应用领域、ES6特性1.1 JavaScript的应用领域 首先很遗憾的一点是，“PHP虽然是最好的语言”，但是它不是最流行的语言   我们先来看一下2017年GitHub上最流行的15种编程语言排行榜 这个数据是 GitHub 根据过去 12 月提交的PR 数量来排名的，虽然不完全准确，但是 PR起码代表了项目的热度与欢迎度   1.1.1 数据可视化 以Processing作为可视化的">
<meta name="twitter:image" content="http://7xq6al.com1.z0.glb.clouddn.com/rank.jpeg">
  
    <link rel="alternative" href="/atom.xml" title="Poetry&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
<script type="text/javascript">
	var _hmt = _hmt || [];
	(function() {
		var hm = document.createElement("script");
		hm.src = "//hm.baidu.com/hm.js?745d1c4c6cc9ed37ba466d15621bcae9";
		var s = document.getElementsByTagName("script")[0]; 
		s.parentNode.insertBefore(hm, s);
	})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay">
	
		<div align="left" style="margin-top:2px;">
<p style="color:#FFFFFF;font-size:12px" class="topUV">您是第

<script src='http://www.xiaoniu168.com/counts3262.html' language='JavaScript' charset='utf-8'></script>
 <script>
      var oP = document.getElementsByClassName("topUV")[0];
      oP.getElementsByTagName("a")[0].setAttribute("href","javascript:void(0);");
  </script>
位访客</p>
</div>
	
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/me.JPG" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Poetry</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Choose a gesture to allow yourself to live irreplaceable.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/poetries" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:me@poetries.top" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="jianshu" target="_blank" href="http://www.jianshu.com/users/94077fcddfc0/latest_articles" title="jianshu">jianshu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/人脉/" style="font-size: 20px;">人脉</a> <a href="/tags/思考/" style="font-size: 10px;">思考</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/效率/" style="font-size: 10px;">效率</a> <a href="/tags/时间/" style="font-size: 10px;">时间</a> <a href="/tags/职场/" style="font-size: 20px;">职场</a> <a href="/tags/阅读体会/" style="font-size: 10px;">阅读体会</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">90后,程序员,热爱编程,执念代码与文学的海洋</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Poetry</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/me.JPG" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Poetry</h1>
			</hgroup>
			
			<p class="header-subtitle">Choose a gesture to allow yourself to live irreplaceable.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/poetries" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:me@poetries.top" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="jianshu" target="_blank" href="http://www.jianshu.com/users/94077fcddfc0/latest_articles" title="jianshu">jianshu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-tech-share-summary" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/03/tech-share-summary/" class="article-date">
  	<time datetime="2018-02-03T07:35:08.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      年终技术分享总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/分享总结/">分享总结</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、JS应用领域、ES6特性"><a href="#一、JS应用领域、ES6特性" class="headerlink" title="一、JS应用领域、ES6特性"></a>一、JS应用领域、ES6特性</h2><h3 id="1-1-JavaScript的应用领域"><a href="#1-1-JavaScript的应用领域" class="headerlink" title="1.1 JavaScript的应用领域"></a>1.1 JavaScript的应用领域</h3><blockquote>
<p>首先很遗憾的一点是，“PHP虽然是最好的语言”，但是它不是最流行的语言</p>
</blockquote>
<ul>
<li>我们先来看一下<code>2017</code>年<code>GitHub</code>上最流行的<code>15</code>种编程语言排行榜</li>
<li>这个数据是 <code>GitHub</code> 根据过去 <code>12</code> 月提交的<code>PR</code> 数量来排名的，虽然不完全准确，但是 <code>PR</code>起码代表了项目的热度与欢迎度</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/rank.jpeg" alt="2017 GitHub 上最受欢迎的前 15 门语言"></p>
<h4 id="1-1-1-数据可视化"><a href="#1-1-1-数据可视化" class="headerlink" title="1.1.1 数据可视化"></a>1.1.1 数据可视化</h4><ul>
<li>以<code>Processing</code>作为可视化的语言——它起始于2001年，它最初是面向美术工作者和设计者创建的，后来变成了全面的设计和原型工具，可以用于创建复杂数据可视化领域</li>
<li><code>Processing</code>被带入了到<code>Web</code>领域产生了<code>Processing.js</code>，还出现了<code>D3.js</code></li>
</ul>
<a id="more"></a>
<h4 id="1-1-2-移动端应用-Cordova"><a href="#1-1-2-移动端应用-Cordova" class="headerlink" title="1.1.2 移动端应用 Cordova"></a>1.1.2 移动端应用 Cordova</h4><blockquote>
<p>接着就是<code>PhoneGap</code>（今天的<code>Cordova</code>），将<code>WebView</code>带向了移动应用，也将<code>JavaScript</code>带向了移动应用</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/Cordova.png" alt="Cordova"></p>
<blockquote>
<p>使用<code>Cordova</code>，可以让我们一次开发多平台发布。我们也顺便提一下<code>Ionic</code>，作为混合应用的翘楚</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/ionic.jpg" alt="ionic"></p>
<h4 id="1-1-3-移动端应用-React-Native"><a href="#1-1-3-移动端应用-React-Native" class="headerlink" title="1.1.3 移动端应用 React Native"></a>1.1.3 移动端应用 React Native</h4><blockquote>
<p>既然我们已经提到了<code>Cordova</code>，那么我们也应该说说<code>React Native</code>。也是一次开发多次运行。虽然它的坑还有很多，但是还是值得期待的</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/react-native.png" alt="native"></p>
<h4 id="1-1-4-服务端-Node-js"><a href="#1-1-4-服务端-Node-js" class="headerlink" title="1.1.4 服务端 Node.js"></a>1.1.4 服务端 Node.js</h4><blockquote>
<p>正是<code>V8</code>的性能将<code>JavaScript</code>带到了一个新的高度，于是<code>Node.js</code>诞生了——前端、后台都可以用<code>JavaScript</code>，一个<code>JavaScript</code>的全栈时代</p>
</blockquote>
<ul>
<li><code>Mongodb</code>作为数据库，<code>Express</code>作为<code>Server</code>端<code>MVC</code>，他们可以提供一个<code>RESTful</code>服务</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/mean.png" alt="mean"></p>
<h4 id="1-1-5-桌面应用-NW-js-和-Electron"><a href="#1-1-5-桌面应用-NW-js-和-Electron" class="headerlink" title="1.1.5 桌面应用 NW.js 和 Electron"></a>1.1.5 桌面应用 NW.js 和 Electron</h4><ul>
<li><code>NW.js</code> 是基于 <code>Chromium</code> 和 <code>Node.js</code> 运行的， 它们可以让我们用<code>HTML</code>和<code>JavaScript</code>来制作桌面应用。除了<code>NW.js</code>还有最近比较火的<code>Electron</code>，<code>Atom</code>编辑器的</li>
<li>与<code>Cordova</code>的多平台构建多版本不同的是，<code>Electron</code>可以在一个平台上构建多个平台的应用。即我们可以在<code>Mac OS</code>上打包出<code>Linux</code>和<code>Windows</code>上的应用，而不需要在<code>Windows</code>再编译一次。</li>
<li>带向了桌面端，让桌面和<code>Web</code>保持了一致。最成功的案例就是估值达30亿美元的<code>Slack</code></li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/slack.jpg" alt="slack"></p>
<h4 id="1-1-6-游戏"><a href="#1-1-6-游戏" class="headerlink" title="1.1.6 游戏"></a>1.1.6 游戏</h4><ul>
<li>自从<code>WebGL</code>被带入浏览器的那一刻，就决定了这又是一个新的天地</li>
<li>让我们忘记编译、启动更新、外挂等等的问题，并且我们还可以一次开发直接运行</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/html5-games.jpg" alt="html5-games"></p>
<h4 id="1-1-7-VR"><a href="#1-1-7-VR" class="headerlink" title="1.1.7 VR"></a>1.1.7 VR</h4><ul>
<li>主要思想还是通过<code>WebView</code>来渲染<code>VR</code>视角</li>
<li>并且各浏览器产商各在推进<code>WebVR</code>为虚拟现实设备显示提供支持</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/threejs-oculus.jpeg" alt="threejs-oculus"></p>
<h4 id="1-1-8-AR"><a href="#1-1-8-AR" class="headerlink" title="1.1.8 AR"></a>1.1.8 AR</h4><ul>
<li>虽然大部分的<code>AR</code>应用可能离我们有点远，但是离我们最近的就是<code>Leap Motion</code>——它可以利用手掌和手指动作来进行输入，但无需手部接触或者触摸</li>
<li>同理于<code>VR</code>，读取传感器的数据，再将其手势交由浏览器端来处理</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/ar.jpg" alt="ar"></p>
<h4 id="1-1-9-硬件"><a href="#1-1-9-硬件" class="headerlink" title="1.1.9 硬件"></a>1.1.9 硬件</h4><blockquote>
<p>早先看到了<code>Arduino</code>在编译的时候，以<code>DSL</code>的方式封装了<code>API</code>。而<code>NodeMCU</code>则内建了<code>Lua</code>语言的支持，可以让开始者使用<code>Lua</code>来开始。 而<code>Tessel</code> 原生就提供了<code>JavaScript</code>运行环境，我们写需要写好<code>JavaScript</code>就可以在上面运行</p>
</blockquote>
<ul>
<li><code>Tessel 2</code>属于配置比较高的硬件</li>
<li>三星设计了<code>JerryScript</code>引擎，它能够运行在小于<code>64KB</code>内存上，且全部代码能够存储在不足<code>200KB</code>的只读存储（<code>ROM</code>）上</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/iotjs.png" alt="iotjs"></p>
<h4 id="1-1-10-物联网"><a href="#1-1-10-物联网" class="headerlink" title="1.1.10 物联网"></a>1.1.10 物联网</h4><ul>
<li>上面说到的只是<code>Node.js</code>在<code>Web</code>中的应用，而物联网和<code>Web</code>的很大不同之处在于，物联网可以使用各种不同的协议，而这些协议都需要<code>Node.js</code>对其的支持。</li>
<li>因此，如果我们需要开始<code>Web</code>版、移动应用，那么我们自然更需要其作为后台</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/lot.png" alt="lot"></p>
<h4 id="1-1-11-操作系统界面"><a href="#1-1-11-操作系统界面" class="headerlink" title="1.1.11 操作系统界面"></a>1.1.11 操作系统界面</h4><ul>
<li>虽然更好的机器带来了更好的性能，但是显然人们对于原生应用的需求并没有那么强烈。<code>Firefox OS</code>已经在移动操作系统败下阵来，但是这个操作被带到了物联网领域</li>
<li>这就意味着，我们可以使用<code>JavaScript</code>来开发操作系统的界面了</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/firefox-os.jpg" alt="firefox-os"></p>
<h3 id="1-2-ES6的一些特性"><a href="#1-2-ES6的一些特性" class="headerlink" title="1.2 ES6的一些特性"></a>1.2 ES6的一些特性</h3><p><img src="http://7xq6al.com1.z0.glb.clouddn.com/es.png" alt="es"></p>
<blockquote>
<p><code>ECMAScript 6（以下简称ES6）</code>是<code>JavaScript</code>语言的下一代标准。因为当前版本的<code>ES6</code>是在<code>2015</code>年发布的，所以又称<code>ECMAScript 2015</code>。也就是说，<code>ES6</code>就是<code>ES2015</code></p>
</blockquote>
<ul>
<li>虽然目前并不是所有浏览器都能兼容<code>ES6</code>全部特性，但越来越多的程序员在实际项目当中已经开始使用<code>ES6</code>了</li>
<li>在我们正式讲解<code>ES6</code>语法之前，我们得先了解下<code>Babel</code></li>
</ul>
<blockquote>
<p><code>Babel</code>是一个广泛使用的<code>ES6</code>转码器，可以将<code>ES6</code>代码转为<code>ES5</code>代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用<code>Babel</code>，具体过程可直接在<code>Babel</code><a href="https://babeljs.io/" target="_blank" rel="noopener">官网</a>查看</p>
</blockquote>
<p><strong>最常用的<code>ES6</code>特性</strong></p>
<h4 id="1-2-1-let-const"><a href="#1-2-1-let-const" class="headerlink" title="1.2.1 let, const"></a>1.2.1 let, const</h4><blockquote>
<p>这两个的用途与<code>var</code>类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'a'</span></span><br><span class="line">    <span class="built_in">console</span>.log(name)  <span class="comment">//a</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name)  <span class="comment">//a</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>var</code> 两次输出都是<code>a</code>，这是因为<code>ES5</code>只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而<code>let</code>则实际上为<code>JavaScript</code>新增了块级作用域。用它所声明的变量，只在<code>let</code>命令所在的代码块内有效</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">'a'</span></span><br><span class="line">    <span class="built_in">console</span>.log(name)  <span class="comment">//a</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name)  <span class="comment">//b</span></span><br></pre></td></tr></table></figure>
<ul>
<li>另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面代码中，变量<code>i</code>是<code>var</code>声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用<code>let</code>则不会出现这个问题</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-class-extends-super"><a href="#1-2-2-class-extends-super" class="headerlink" title="1.2.2 class, extends, super"></a>1.2.2 class, extends, super</h4><blockquote>
<ul>
<li>这三个特性涉及了<code>ES5</code>中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？有了<code>ES6</code>我们不再烦恼！</li>
<li><code>ES6</code>提供了更接近传统语言的写法，引入了<code>Class</code>（类）这个概念。新的<code>class</code>写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'animal'</span></span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.type + <span class="string">' says '</span> + say)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal()</span><br><span class="line">animal.says(<span class="string">'hello'</span>) <span class="comment">//animal says hello</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'cat'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line">cat.says(<span class="string">'hello'</span>) <span class="comment">//cat says hello</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面代码首先用<code>class</code>定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。简单地说，<code>constructor</code>内定义的方法和属性是实例对象自己的，而<code>constructor</code>外定义的方法和属性则是所有实例对象可以共享的</li>
<li><code>Class</code>之间可以通过<code>extends</code>关键字实现继承，这比<code>ES5</code>的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个<code>Cat</code>类，该类通过<code>extends</code>关键字，继承了<code>Animal</code>类的所有属性和方法</li>
<li><code>super</code>关键字，它指代父类的实例（即父类的<code>this</code>对象）。子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用super方法，子类就得不到<code>this</code>对象</li>
<li><code>ES6</code>的继承机制，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code></li>
<li>以上三个东西在最新版<code>React</code>中出现得很多。创建的每个<code>component</code>都是一个继承<code>React.Component</code>的类</li>
</ul>
<h4 id="1-2-3-arrow-function"><a href="#1-2-3-arrow-function" class="headerlink" title="1.2.3 arrow function"></a>1.2.3 arrow function</h4><blockquote>
<p><code>ES6</code>最最常用的一个新特性了，用它来写`function比原来的写法要简洁清晰很多</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125; <span class="comment">//ES5</span></span><br><span class="line">(i) =&gt; i + <span class="number">1</span> <span class="comment">//ES6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果方程比较复杂，则需要用<code>{}</code>把代码包起来</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">    x++;</span><br><span class="line">    y--;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">(x, y) =&gt; &#123;x++; y--; <span class="keyword">return</span> x+y&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-template-string"><a href="#1-2-4-template-string" class="headerlink" title="1.2.4 template string"></a>1.2.4 template string</h4><blockquote>
<p>当我们要插入大段的<code>html</code>内容到文档中时，传统的写法非常麻烦</p>
</blockquote>
<ul>
<li>可以先看下面一段代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#result"</span>).append(</span><br><span class="line">  <span class="string">"There are &lt;b&gt;"</span> + basket.count + <span class="string">"&lt;/b&gt; "</span> +</span><br><span class="line">  <span class="string">"items in your basket, "</span> +</span><br><span class="line">  <span class="string">"&lt;em&gt;"</span> + basket.onSale +</span><br><span class="line">  <span class="string">"&lt;/em&gt; are on sale!"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>我们要用一堆的<code>&#39;+&#39;</code>号来连接文本与变量，而使用<code>ES6</code>的新特性模板字符串``后，我们可以直接这么来写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#result"</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用反引号来标识起始，用<code>${}</code>来引用变量，而且所有的空格和缩进都会被保留在输出之中</p>
</blockquote>
<ul>
<li><code>React Router</code>从第<code>1.0.3</code>版开始也使用<code>ES6</code>语法了，比如这个例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;<span class="string">`/taco/<span class="subst">$&#123;taco.name&#125;</span>`</span>&#125;&gt;&#123;taco.name&#125;&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-5-destructuring"><a href="#1-2-5-destructuring" class="headerlink" title="1.2.5 destructuring"></a>1.2.5 destructuring</h4><blockquote>
<p><code>ES6</code>允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（<code>Destructuring</code>）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">'ken'</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">'lili'</span></span><br><span class="line"><span class="keyword">let</span> zoo = &#123;<span class="attr">cat</span>: cat, <span class="attr">dog</span>: dog&#125;</span><br><span class="line"><span class="built_in">console</span>.log(zoo)  <span class="comment">//Object &#123;cat: "ken", dog: "lili"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用ES6完全可以像下面这么写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">'ken'</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">'lili'</span></span><br><span class="line"><span class="keyword">let</span> zoo = &#123;cat, dog&#125;</span><br><span class="line"><span class="built_in">console</span>.log(zoo)  <span class="comment">//Object &#123;cat: "ken", dog: "lili"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>反过来可以这么写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123;<span class="attr">type</span>: <span class="string">'animal'</span>, <span class="attr">many</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; type, many&#125; = dog</span><br><span class="line"><span class="built_in">console</span>.log(type, many)   <span class="comment">//animal 2</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-6-default-rest"><a href="#1-2-6-default-rest" class="headerlink" title="1.2.6 default, rest"></a>1.2.6 default, rest</h4><blockquote>
<p><code>default</code>很简单，意思就是默认值。大家可以看下面的例子，调用<code>animal()</code>方法时忘了传参数，传统的做法就是加上这一句<code>type = type || &#39;cat&#39;</code>来指定默认值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">    type = type || <span class="string">'cat'</span>  </span><br><span class="line">    <span class="built_in">console</span>.log(type)</span><br><span class="line">&#125;</span><br><span class="line">animal()</span><br></pre></td></tr></table></figure>
<ul>
<li>如果用<code>ES6</code>我们而已直接这么写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params">type = <span class="string">'cat'</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(type)</span><br><span class="line">&#125;</span><br><span class="line">animal()</span><br></pre></td></tr></table></figure>
<ul>
<li>最后一个<code>rest(展开运算符)</code>语法也很简单，直接看例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animals</span>(<span class="params">...types</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(types)</span><br><span class="line">&#125;</span><br><span class="line">animals(<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'fish'</span>) <span class="comment">//["cat", "dog", "fish"]</span></span><br></pre></td></tr></table></figure>
<h2 id="二、前端工程化浅析"><a href="#二、前端工程化浅析" class="headerlink" title="二、前端工程化浅析"></a>二、前端工程化浅析</h2><h3 id="2-1-前端工程化的历史模式演变"><a href="#2-1-前端工程化的历史模式演变" class="headerlink" title="2.1 前端工程化的历史模式演变"></a>2.1 前端工程化的历史模式演变</h3><h4 id="2-1-1-Web-1-0-时代"><a href="#2-1-1-Web-1-0-时代" class="headerlink" title="2.1.1  Web 1.0 时代"></a>2.1.1  Web 1.0 时代</h4><p><img src="http://7xq6al.com1.z0.glb.clouddn.com/web1.png" alt=""></p>
<blockquote>
<p><code>Web 1.0</code> 时代，页面由 <code>JSP</code>、<code>PHP</code> 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 <code>Web Server</code>层</p>
</blockquote>
<ul>
<li>这种模式的好处是：简单明快，本地起一个 <code>Tomcat</code> 或 <code>Apache</code> 就能开发，调试什么的都还好，只要业务不太复杂</li>
<li>然而业务的复杂会让 <code>Service</code>越来越多，调用关系变复杂，前端搭建本地环境不再是一件简单的事</li>
</ul>
<blockquote>
<p>如何让前后端分工更合理高效，如何提高代码的可维护性，在 <code>Web</code> 开发中很重要。下面我们继续来看技术架构的演变如何解决这两个问题</p>
</blockquote>
<h4 id="2-1-2-后端为主的-MVC-时代"><a href="#2-1-2-后端为主的-MVC-时代" class="headerlink" title="2.1.2  后端为主的 MVC 时代"></a>2.1.2  后端为主的 MVC 时代</h4><blockquote>
<p>为了降低复杂度，以后端为出发点，有了 <code>Web Server</code> 层的架构升级，比如  <code>Spring MVC</code>，这是后端的 <code>MVC</code> 时代</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/mvc.png" alt=""></p>
<blockquote>
<p>代码可维护性得到明显好转，<code>MVC</code> 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方</p>
</blockquote>
<h4 id="2-1-3-Ajax-带来的-SPA-时代-web2-0"><a href="#2-1-3-Ajax-带来的-SPA-时代-web2-0" class="headerlink" title="2.1.3  Ajax 带来的 SPA 时代(web2.0)"></a>2.1.3  Ajax 带来的 SPA 时代(web2.0)</h4><blockquote>
<p><code>2004</code> 年 <code>Gmail</code>像风一样的女子来到人间，很快 <code>2005</code> 年 <code>Ajax</code> 正式提出，加上<code>CDN</code>开始大量用于静态资源存储，于是出现了 <code>JavaScript</code> 王者归来的 <code>SPA</code> （Single Page Application 单页面应用）时代</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/web2.png" alt=""></p>
<blockquote>
<p>这种模式下，前后端的分工非常清晰，前后端的关键协作点是 <code>Ajax</code>接口。看起来是如此美妙，但回过头来看看的话，这与 <code>JSP</code> 时代区别不大。复杂度从服务端的 <code>JSP</code> 里移到了浏览器的 <code>JavaScript</code>，浏览器端变得很复杂。类似 <code>Spring MVC</code>，这个时代开始出现浏览器端的分层架构</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/spa.png" alt=""></p>
<p><strong>对于 SPA 应用，有几个很重要的挑战</strong></p>
<ul>
<li><strong>前后端接口的约定</strong><ul>
<li>有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发</li>
</ul>
</li>
<li><strong>前端开发的复杂度控制</strong><ul>
<li><code>SPA</code> 应用大多以功能交互型为主，<code>JavaScript</code> 代码过十万行很正常。大量 <code>JS</code> 代码的组织，与 <code>View</code> 层的绑定等，都不是容易的事情</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>SPA</code> 让前端看到了一丝绿色，但依旧是在荒漠中行走</p>
</blockquote>
<h4 id="2-1-4-前端为主的-MV-时代"><a href="#2-1-4-前端为主的-MV-时代" class="headerlink" title="2.1.4  前端为主的 MV* 时代"></a>2.1.4  前端为主的 MV* 时代</h4><blockquote>
<p>为了降低前端开发复杂度，除了 <code>Backbone</code>，还有大量框架涌现，比如 <code>EmberJS</code>、<code>KnockoutJS</code>、<code>AngularJS</code> 等。这些框架总的原则是先按类型分层，比如 <code>Templates</code>、<code>Controllers</code>、<code>Models</code>，然后再在层内做切分，如下图：</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/mvvm.png" alt=""></p>
<p><strong>这样做的好处</strong></p>
<ul>
<li>前后端职责很清晰<ul>
<li>前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 <code>RESTful</code> 等接口</li>
</ul>
</li>
<li>前端开发的复杂度可控<ul>
<li>前端代码很重，但合理的分层，让前端代码能各司其职</li>
</ul>
</li>
<li>部署相对独立，产品体验可以快速改进</li>
</ul>
<p><strong>但依旧有不足之处</strong></p>
<ul>
<li>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化</li>
<li>全异步，对 <code>SEO</code> 不利。往往还需要服务端做同步渲染的降级方案</li>
<li>性能并非最佳，特别是移动互联网环境下</li>
<li><code>SPA</code> 不能满足所有需求，依旧存在大量多页面应用。<code>URL Design</code> 需要后端配合，前端无法完全掌控</li>
</ul>
<h4 id="2-1-5-Node-带来的全栈时代"><a href="#2-1-5-Node-带来的全栈时代" class="headerlink" title="2.1.5  Node 带来的全栈时代"></a>2.1.5  Node 带来的全栈时代</h4><blockquote>
<p>前端为主的 <code>MV*</code> 模式解决了很多问题，但如上所述，依旧存在不少不足之处。随着 <code>Node.js</code> 的兴起，<code>JavaScript</code> 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/node.png" alt=""></p>
<p><strong>在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职</strong></p>
<ul>
<li><code>Front-end UI layer</code> 处理浏览器层的展现逻辑。通过 <code>CSS</code>渲染样式，通过 <code>JavaScript</code> 添加交互功能，<code>HTML</code> 的生成也可以放在这层，具体看应用场景</li>
<li><code>Back-end UI layer</code> 处理路由、模板、数据获取、<code>cookie</code> 等。通过路由，前端终于可以自主把控 <code>URL Design</code>，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</li>
<li>通过 <code>Node</code>，<code>Web Server</code>层也是 <code>JavaScript</code>代码，这意味着部分代码可前后复用，需要 <code>SEO</code> 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</li>
</ul>
<p><strong>基于 Node 的全栈模式，依旧面临很多挑战</strong></p>
<ul>
<li>需要前端对服务端编程有更进一步的认识。比如 <code>network/tcp</code> 等知识的掌握</li>
<li><code>Node</code> 层与<code>Java</code>层的高效通信。<code>Node</code> 模式下，都在服务器端，<code>RESTful HTTP</code> 通信未必高效，通过<code>SOAP</code> 等方式通信更高效</li>
</ul>
<h4 id="2-1-6-总结"><a href="#2-1-6-总结" class="headerlink" title="2.1.6 总结"></a>2.1.6 总结</h4><ul>
<li>模式没有好坏高下之分，只有合不合适</li>
<li><code>Ajax</code> 给前端开发带来了一次质的飞跃，<code>Node</code> 很可能是第二次</li>
<li>上面种种模式，都是让前后端的职责更清晰，分工更合理高效</li>
<li>还有个原则，让合适的人做合适的事。比如 <code>Web Server</code> 层的 <code>UI Layer</code> 开发，前端是更合适的人选</li>
</ul>
<h3 id="2-2-什么是前端工程化"><a href="#2-2-什么是前端工程化" class="headerlink" title="2.2 什么是前端工程化"></a>2.2 什么是前端工程化</h3><blockquote>
<p>大体的来说，前端工程化有两层含义</p>
</blockquote>
<p><strong>广义的前端工程化</strong></p>
<blockquote>
<p>前端工程是软件工程的一个子类，指的是将软件工程的方法和原理运用在前端开发中, 目的是实现 高效开发，有效协同，质量可控</p>
</blockquote>
<p><strong>狭义的前端工程化</strong></p>
<blockquote>
<p>前端工程是指将 开发阶段 的代码转变成 生产环境 的代码的 一系列步骤。主要包括 构建 , 分支管理 , 自动化测试, 部署 等</p>
</blockquote>
<p><strong>简单总结一下就是</strong></p>
<ul>
<li>广义的前端工程是一个系统工程，需要从软件生命周期的各个方面入手，本质上属于管理科学的方法论</li>
<li>狭义的前端工程是前端开发流程中的一部分，本质上属于软件技术的范畴和开发的最佳实践。我们平时提到的前端，如果特别说明，一般指的就是狭义上的前端工程</li>
<li>具体到前端工程化，面临的问题是如何提高编码-&gt;测试-&gt;维护阶段的生产效率</li>
</ul>
<h3 id="2-3-为什么要提前端工程化"><a href="#2-3-为什么要提前端工程化" class="headerlink" title="2.3 为什么要提前端工程化"></a>2.3 为什么要提前端工程化</h3><blockquote>
<p>简单来说，前端越来越复杂，设计的问题和环节也越来越多，不采用工程化管理，就无法很好的实现团队协同和降低复杂性。 具体的原因大概有以下几点</p>
</blockquote>
<p><strong>前端范畴不断扩大</strong></p>
<blockquote>
<p>早期的前端只需要适配桌面浏览器，而现在的前端，需要适配不同类型和尺寸的设备，包括移动端网页，<code>app</code>应用等</p>
</blockquote>
<p><strong>前后端分离</strong></p>
<blockquote>
<p>早期的前端只是后端 <code>MVC</code> 框架的一层模块， 而现在的前端普遍是从后端接口获取数据，编写处理逻辑，各种前端<code>mvc</code>前端框架也层出不穷</p>
</blockquote>
<p><strong>模块化开发的出现</strong></p>
<blockquote>
<p>现在的前端开发不再是从零写起，重复造轮子，而是会引用大量内部和外部的组件和模块，这也导致前端必须进行模块管理</p>
</blockquote>
<p><strong>转码器的盛行</strong></p>
<blockquote>
<p>为了提高效率，前端工程往往不会直接写<code>html</code>,<code>css</code>,和<code>js</code>代码，而是改用其他格式书写，再用工具编译为目标格式。比如用<code>Jade</code> 写<code>HTML</code>，用<code>less</code>／<code>sass</code>／<code>stylus</code>编写<code>CSS</code>,用<code>ES6</code>/<code>Typescript</code>/.. 编写<code>JavaScript</code>.</p>
</blockquote>
<p><strong>开发流程和团队</strong></p>
<blockquote>
<p>早期的前端团队往往只有几个人，而现在的前端团队可以扩展到几十人，甚至上百人。每个人只负责自己的一块内容。所以，如何协调多人多团队的工作，保证沟通顺畅，保证权限管理，越来越成为一大问题</p>
</blockquote>
<h3 id="2-4-前端工程化的具体内容"><a href="#2-4-前端工程化的具体内容" class="headerlink" title="2.4 前端工程化的具体内容"></a>2.4 前端工程化的具体内容</h3><ul>
<li><strong>代码规范</strong>: 保证团队所有成员以同样的规范开发代码</li>
<li><strong>分支管理</strong>: 不同的开发人员开发不同的功能或组件，按照统一的流程合并到主干</li>
<li><strong>模块管理</strong>: 一方面，团队引用的模块应该是规范的;另一方面，必须保证这些模块可以正确的加入到最终编译好的包文件中</li>
<li><strong>自动化测试</strong>：为了保证和并进主干的代码达到质量标准，必须有测试，而且测试应该是自动化的，可以回归的</li>
<li><strong>构建</strong>：主干更新以后，自动将代码编译为最终的目标格式，并且准备好各种静态资源</li>
<li><strong>部署</strong>:  将构建好的代码部署到生产环境</li>
</ul>
<h3 id="2-5-前端工程化面临的问题"><a href="#2-5-前端工程化面临的问题" class="headerlink" title="2.5 前端工程化面临的问题"></a>2.5 前端工程化面临的问题</h3><blockquote>
<p>要解决前端工程化的问题，从两个角度入手：<strong>开发</strong>和<strong>部署</strong></p>
</blockquote>
<p><strong>从开发角度，要解决的问题包括</strong></p>
<ul>
<li>提高开发生产效率</li>
<li>降低维护难度</li>
</ul>
<p><strong>这两个问题的解决方案有两点</strong></p>
<ul>
<li>制定开发规范，提高团队协作能力；</li>
<li>模块化开发</li>
</ul>
<p><strong>从部署角度，要解决的问题主要是资源管理，包括</strong></p>
<ul>
<li>代码审查</li>
<li>压缩打包</li>
<li>增量更新</li>
<li>单元测试</li>
</ul>
<blockquote>
<p>要解决上述问题，需要引入构建/编译阶段</p>
</blockquote>
<h3 id="2-6-构建-amp-编译"><a href="#2-6-构建-amp-编译" class="headerlink" title="2.6 构建&amp;编译"></a>2.6 构建&amp;编译</h3><blockquote>
<ul>
<li>自<code>Node.js</code>问世以来，前端圈子一直传播着一个词：颠覆。前端工程师要借助<code>Node.js</code>颠覆以往的<code>web</code>开发模式，简单说就是用<code>Node.js</code>取代<code>php</code>、<code>ruby</code>、<code>python</code>等语言搭建<code>web server</code></li>
<li>催生了大量前端工程化工具（<code>Grunt</code>、<code>Gulp</code>、<code>Browserify</code>、<code>Webpack</code>、<code>Rollup</code>、<code>Parcel</code>…..)，提高了前端开发效率并使大型<code>Web</code>前端项目的开发更为方便和规范</li>
</ul>
<p>我们首先看一下在整个前端工程系统中，构建扮演什么角色？请看下图</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/build.png" alt="build"></p>
<blockquote>
<p>大前端体系下，前端开发人员掌握着<code>Node.js</code>搭建的<code>web server</code>层。不论是大前端还是“小”前端，构建阶段在两种模式下的作用完全一致，构建的作用就是对静态资源以及模板进行处理，换句话说：构建的核心是资源管理。</p>
</blockquote>
<h3 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7 总结"></a>2.7 总结</h3><p><strong>一个完整的前端工程体系应该包括</strong></p>
<ul>
<li>统一的开发规范</li>
<li>组件化开发</li>
<li>构建流程</li>
</ul>
<blockquote>
<ul>
<li>开发规范和组件化开发面向的开发阶段，宗旨是提高团队协作能力，提高开发效率并降低维护成本</li>
<li>构建工具和平台解决了<code>web</code>产品一系列的工程问题，旨在提高<code>web</code>产品的性能表现，提高开发效率</li>
</ul>
</blockquote>
<h2 id="三、React实践"><a href="#三、React实践" class="headerlink" title="三、React实践"></a>三、React实践</h2><blockquote>
<p>随着近几年的发展，前端已经不单单是<code>html+css</code>编写样式静态页了，而是往着更深层次发展，越来越多的前端<code>js</code>框架：<code>angular</code>、<code>vue</code>、<code>react</code>纷纷研发出来了。该如何选择？</p>
</blockquote>
<h3 id="3-1-选型对比"><a href="#3-1-选型对比" class="headerlink" title="3.1 选型对比"></a>3.1 选型对比</h3><h4 id="3-1-1-过去一年的Google趋势分析"><a href="#3-1-1-过去一年的Google趋势分析" class="headerlink" title="3.1.1 过去一年的Google趋势分析"></a>3.1.1 过去一年的Google趋势分析</h4><blockquote>
<p>下图是进行了过去一年中国区的比较，这个结果是网页搜索的结果，对应颜色可以看到相应的折线图，<code>React</code>整体很高，<code>vue</code>第二，<code>angularjs</code>依旧占据很大份额</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/trend.png" alt="trend"></p>
<h4 id="3-1-2-React、Vue、angular优缺点对比"><a href="#3-1-2-React、Vue、angular优缺点对比" class="headerlink" title="3.1.2 React、Vue、angular优缺点对比"></a>3.1.2 React、Vue、angular优缺点对比</h4><h5 id="3-1-2-1-React"><a href="#3-1-2-1-React" class="headerlink" title="3.1.2.1 React"></a>3.1.2.1 React</h5><p><strong>优点</strong></p>
<ul>
<li><code>React</code>速度很快：它并不直接对<code>DOM</code>进行操作，引入了一个叫做虚拟<code>DOM</code>的概念，安插在<code>javascript</code>逻辑和实际的<code>DOM</code>之间，性能好</li>
<li>跨浏览器兼容：虚拟<code>DOM</code>帮助我们解决了跨浏览器问题，它为我们提供了标准化的<code>API</code>，甚至在<code>IE8</code>中都是没问题的</li>
<li>一切都是<code>component</code>：代码更加模块化，重用代码更容易，可维护性高</li>
<li>单向数据流：<code>Flux</code>是一个用于在<code>JavaScript</code>应用中创建单向数据层的架构，它随着<code>React</code>视图库的开发而被<code>Facebook</code>概念化</li>
<li>同构、纯粹的<code>javascript</code>：因为搜索引擎的爬虫程序依赖的是服务端响应而不是<code>JavaScript</code>的执行，预渲染你的应用有助于搜索引擎优化</li>
<li>兼容性好：比如使用<code>RequireJS</code>来加载和打包，而<code>Browserify</code>和<code>Webpack</code>适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><code>React</code>本身只是一个<code>V</code>而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上<code>ReactRouter</code>和<code>Flux</code>才能写大型应用</li>
<li>大多数坑没踩出来，大概就是现在还太新了很难说将来有没有大的<code>API</code>变化</li>
</ul>
<h5 id="3-1-2-2-Angular"><a href="#3-1-2-2-Angular" class="headerlink" title="3.1.2.2 Angular"></a>3.1.2.2 Angular</h5><blockquote>
<p><code>AngularJS</code>最近很火，追随者也很多。完全使用<code>JavaScript</code>编写的客户端技术。同其他历史悠久的<code>Web</code>技术（<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>）配合使用，使<code>Web</code>应用开发比以往更简单、更快捷“。当你学习它的时候，我相信你会被它的很多新特效所吸引</p>
</blockquote>
<p><strong>优点</strong></p>
<ul>
<li>是一个比较完善的前端<code>MVW</code>框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 <code>Angular</code> 指令。</li>
<li><code>AngularJS</code>有<code>Google</code>来维护，有了一个强大的后台，社区也非常活泼，能够很好促进它的发展</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>学习起来有难度，比较难理解一些</li>
<li><code>AngularJS2.0</code>和<code>1.0</code>相比，会把之前的推翻重写，两个框架的改变很大，基本是两个框架了，等于是说等到<code>2.0</code>出来后又需要从头开始</li>
</ul>
<h5 id="3-1-2-3-Vue"><a href="#3-1-2-3-Vue" class="headerlink" title="3.1.2.3 Vue"></a>3.1.2.3 Vue</h5><blockquote>
<p><code>Vue.js</code> 专注于 <code>MVVM</code> 模型的 <code>ViewModel</code> 层。它通过双向数据绑定把 <code>View</code> 层和 <code>Model</code> 层连接了起来。实际的 <code>DOM</code> 封装和输出格式都被抽象为了<code>Directives</code>和 <code>Filters</code>。<code>Vue.js</code>和其他库相比是一个小而美的库</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/view.png" alt="viewModel"></p>
<p><strong>优点</strong></p>
<ul>
<li>简单：官方文档很清晰，比 <code>Angular</code> 简单易学</li>
<li>快速：异步批处理方式更新 <code>DOM</code></li>
<li>组合：用解耦的、可复用的组件组合你的应用程序</li>
<li>对模块友好：可以通过 <code>NPM</code>安装，使用场景更加灵活</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>新生儿：<code>Vue.js</code>是一个新的项目，没有<code>angular</code>那么成熟</li>
<li>影响度不是很大：生态不是很完善</li>
<li>不支持<code>IE8</code>：不过<code>AngularJS 1.3</code>也抛弃了对<code>IE8</code>的支持。这一点对于那些需要支持<code>IE8</code>的项目就不好了</li>
</ul>
<table>
<thead>
<tr>
<th>Decision point</th>
<th>Angular2</th>
<th>React</th>
<th>Vue</th>
</tr>
</thead>
<tbody>
<tr>
<td>稳定</td>
<td><code>YES</code></td>
<td><code>YES</code></td>
<td><code>YES</code></td>
</tr>
<tr>
<td>社区生态</td>
<td>完善,<code>Google</code>维护</td>
<td>大型的技术生态系统,<code>Facebook</code>维护</td>
<td>个人维护</td>
</tr>
<tr>
<td>文档是否全面</td>
<td><code>YES</code></td>
<td><code>YES</code></td>
<td><code>YES</code></td>
</tr>
<tr>
<td>学习曲线</td>
<td>很陡</td>
<td>一般</td>
<td>平缓</td>
</tr>
<tr>
<td><code>Small</code></td>
<td><code>566K</code></td>
<td><code>139K</code></td>
<td><code>58.8K</code></td>
</tr>
<tr>
<td><code>Coding Speed</code></td>
<td><code>Slow</code></td>
<td><code>Normal</code></td>
<td><code>Fast</code></td>
</tr>
<tr>
<td>是否使用<code>virtual DOM</code></td>
<td></td>
<td><code>YES</code></td>
<td><code>YES</code></td>
</tr>
</tbody>
</table>
<h3 id="3-2-在结算报表中的应用"><a href="#3-2-在结算报表中的应用" class="headerlink" title="3.2 在结算报表中的应用"></a>3.2 在结算报表中的应用</h3><h4 id="3-2-1-React概况"><a href="#3-2-1-React概况" class="headerlink" title="3.2.1 React概况"></a>3.2.1 React概况</h4><h5 id="3-2-1-1-概况"><a href="#3-2-1-1-概况" class="headerlink" title="3.2.1.1 概况"></a>3.2.1.1 概况</h5><ul>
<li><code>React</code> 起源于 <code>Facebook</code> 的内部项目，因为该公司对市场上所有 <code>JavaScript MVC</code> 框架，都不满意，就决定自己写一套。</li>
<li><code>React</code>是一个帮助构建页面<code>UI</code>的库，相较于<code>MVC</code>框架，只能算是其中的<code>View</code>层。能够帮助我们把页面分割成各个单独独立的小模块，每个小模块就是一个组件，这些组件相互组合、嵌套，就构成了复杂庞大的页面</li>
<li><code>React</code>只是一个库，不是一个框架，它只提供<code>UI</code>层的解决方案，在实际使用中需要搭配其他库实现完整的解决方案</li>
</ul>
<p><strong>解决前端开发的那些痛点</strong></p>
<ul>
<li>.隔离<code>DOM</code>操作，所有操作全部转换成对数据的操作，通过改变数据来改变页面显示</li>
<li>数据绑定，单项数据流</li>
<li>组件化，<code>React</code>天生组件化，每个模块都是一个单独的组件，可以单独使用，也可以和其他模块组合、嵌套使用</li>
<li>可维护行增强，每个组件单独维护，互相不受牵扯</li>
<li>运行效率，使用虚拟<code>DOM</code>，减少<code>DOM</code>操作</li>
</ul>
<h5 id="3-2-1-2-核心概念"><a href="#3-2-1-2-核心概念" class="headerlink" title="3.2.1.2 核心概念"></a>3.2.1.2 核心概念</h5><blockquote>
<p><code>React</code> 的核心概念只有 <code>2</code> 点</p>
</blockquote>
<ul>
<li>声明式渲染(<code>Declarative</code>)</li>
<li>基于组件(<code>Component-Based</code>)</li>
</ul>
<p><strong>声明式渲染</strong></p>
<blockquote>
<p>和普通模板不同的是，<code>React</code> 模板写在 <code>JS</code> 文件中，而不是 <code>html</code> 的 <code>&lt;script&gt;</code> 标签中。能使用所有 <code>JS</code> 语法，而不只有模板语法，所以更加灵活</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formatName = <span class="function"><span class="params">user</span> =&gt;</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'poetry'</span>,</span><br><span class="line">  lastName: <span class="string">'xie'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>React</code> 可局部渲染，且只渲染改变了的数据</li>
</ul>
<h5 id="3-2-1-3-生命周期"><a href="#3-2-1-3-生命周期" class="headerlink" title="3.2.1.3 生命周期"></a>3.2.1.3 生命周期</h5><p><img src="http://7xq6al.com1.z0.glb.clouddn.com/life1.png" alt="life"></p>
<h4 id="3-2-2-CRM项目整体结构"><a href="#3-2-2-CRM项目整体结构" class="headerlink" title="3.2.2 CRM项目整体结构"></a>3.2.2 CRM项目整体结构</h4><p><img src="http://7xq6al.com1.z0.glb.clouddn.com/crm.png" alt="crm架构图"></p>
<h4 id="3-2-3-性能优化"><a href="#3-2-3-性能优化" class="headerlink" title="3.2.3 性能优化"></a>3.2.3 性能优化</h4><h5 id="3-2-3-1-PureRenderMixin-优化"><a href="#3-2-3-1-PureRenderMixin-优化" class="headerlink" title="3.2.3.1 PureRenderMixin 优化"></a>3.2.3.1 PureRenderMixin 优化</h5><blockquote>
<p><code>React</code> 最基本的优化方式是使用<code>PureRenderMixin</code>，安装工具 <code>npm i react-addons-pure-render-mixin --save</code>，然后在组件中引用并使用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PureRenderMixin <span class="keyword">from</span> <span class="string">'react-addons-pure-render-mixin'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他内容...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用<code>this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);</code>的意思是重写组件的<code>shouldComponentUpdate</code>函数，在每次更新之前判断<code>props</code>和<code>state</code>，如果有变化则返回<code>true</code>，无变化则返回<code>false</code></li>
<li>因此，我们在开发过程中，在每个 <code>React</code>组件中都尽量使用<code>PureRenderMixin</code></li>
</ul>
<h4 id="3-2-4-一些坑"><a href="#3-2-4-一些坑" class="headerlink" title="3.2.4 一些坑"></a>3.2.4 一些坑</h4><ul>
<li>升级最新版的<code>react-router</code>写法的变更</li>
<li>使用<code>mobile-ant-design</code>组件库在<code>iphone</code>下出现兼容性问题</li>
</ul>
<h2 id="四、Chrome开发者工具介绍"><a href="#四、Chrome开发者工具介绍" class="headerlink" title="四、Chrome开发者工具介绍"></a>四、Chrome开发者工具介绍</h2><h3 id="4-1-如何查看修改DOM"><a href="#4-1-如何查看修改DOM" class="headerlink" title="4.1 如何查看修改DOM"></a>4.1 如何查看修改DOM</h3><h4 id="4-1-1-Elements面板的使用"><a href="#4-1-1-Elements面板的使用" class="headerlink" title="4.1.1 Elements面板的使用"></a>4.1.1 Elements面板的使用</h4><blockquote>
<p>你可能经常会想能直接在浏览器里更改网页的文本内容。答案是肯定的，你可以只通过一行简单的指令把<code>Chrome</code>变成所见即所得的编辑器，直接在网页上随心所欲地删改文字</p>
</blockquote>
<ul>
<li>打开<code>Chrome</code>的开发者控制台，输入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.contentEditable=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-查看DOM树"><a href="#4-1-2-查看DOM树" class="headerlink" title="4.1.2 查看DOM树"></a>4.1.2 查看DOM树</h4><blockquote>
<p>打开<code>Element</code>面板，可以查看所有<code>DOM</code>节点，包括<code>CSS</code>和<code>JavaScript</code>，如下图所示，左侧为<code>DOM</code>树，右侧为<code>CSS</code>样式。</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/dom.png" alt="dom"></p>
<ul>
<li>点击“图标1”，可以在新窗口中打开开发者工具，再次点击回到当前网页；</li>
<li>点击“图标2”，可以调出控制台，可以在控制台里输入并执行<code>JavaScript</code>代码，查看当前网页的错误和日志等；</li>
<li>点击“图标3”，可以选取当前页面的<code>HTML</code>元素</li>
</ul>
<h4 id="4-1-3-选取DOM节点"><a href="#4-1-3-选取DOM节点" class="headerlink" title="4.1.3 选取DOM节点"></a>4.1.3 选取DOM节点</h4><p><img src="http://7xq6al.com1.z0.glb.clouddn.com/select-dom.png" alt="select-dom"></p>
<h4 id="4-1-4-增加、删除和修改DOM节点"><a href="#4-1-4-增加、删除和修改DOM节点" class="headerlink" title="4.1.4 增加、删除和修改DOM节点"></a>4.1.4 增加、删除和修改DOM节点</h4><blockquote>
<p>在<code>Element</code>面板中，选择<code>DOM</code>节点，在文本处右击鼠标，会弹出一个菜单，如下图所示</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/add-dom.png" alt="add-dom"></p>
<h3 id="4-2-performance性能分析工具"><a href="#4-2-performance性能分析工具" class="headerlink" title="4.2 performance性能分析工具"></a>4.2 performance性能分析工具</h3><blockquote>
<p>我们都知道浏览器从打开 <code>url</code> 到整个页面渲染完成，中间的过程，大致是 <code>DOM</code> 解析，<code>CSSOM</code> 解析，<code>JS</code> 解析，渲染。</p>
</blockquote>
<p><strong>切换至Performance标签</strong></p>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/per.png" alt="performance"></p>
<blockquote>
<p>先来看看在 <code>Chrome</code> 浏览器控制台中执行 <code>window.performance</code> 会出现什么</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/dd-co.png" alt="d"></p>
<ul>
<li><code>performance</code> 有好几个属性，但是由于浏览器支持程度不同，我们主要用到的是支持最广泛，最常用的 <code>performance.timing</code> 这个属性</li>
</ul>
<blockquote>
<p><code>performance.timing</code> 主要属性如下： </p>
</blockquote>
<p>这些属性记录的都是时间戳</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">navigationStart: <span class="number">1500979373880</span>,    <span class="comment">// 地址栏输入 url 回车之后，或者用户点击链接开始打开 href 时</span></span><br><span class="line">unloadEventStart: <span class="number">0</span>,    <span class="comment">// 前一个页面触发 unload 时间时，和当前页面同源时才统计</span></span><br><span class="line">unloadEventEnd: <span class="number">0</span>,      <span class="comment">// 前一个页面 unload 事件处理函数结束时，和当前页面同源时才统计</span></span><br><span class="line">redirectStart: <span class="number">0</span>,       <span class="comment">// 重新向到当前页面时，同源才统计</span></span><br><span class="line">redirectEnd: <span class="number">0</span>,         <span class="comment">// 重定向结束时，同源才统计</span></span><br><span class="line">fetchStart: <span class="number">1500979373880</span>,    <span class="comment">// 开始请求页面</span></span><br><span class="line">domainLookupStart: <span class="number">1500979373880</span>,    <span class="comment">// 开始解析域名，如果是本地有 DNS 缓存，或者使用 http-alive 复用 TCP 连接，则此属性值和 fetchStart 相同</span></span><br><span class="line">domainLookupEnd: <span class="number">1500979373880</span>,    <span class="comment">// 域名解析结束时，如果是本地有 DNS 缓存，或者使用 http-alive 复用 TCP 连接 ，则此属性值和 fetchStart 相同</span></span><br><span class="line">connectStart: <span class="number">1500979373886</span>,       <span class="comment">// 开始向服务器请求建立连接</span></span><br><span class="line">secureConnectionStart: <span class="number">0</span>,          <span class="comment">// 开始进行 SSL 连接，不走 HTTPS 这个属性值为0</span></span><br><span class="line">connectEnd: <span class="number">1500979373887</span>,         <span class="comment">// 连接建立完毕</span></span><br><span class="line">requestStart: <span class="number">1500979373887</span>,       <span class="comment">// 开始向服务器发起请求</span></span><br><span class="line">responseStart: <span class="number">1500979374433</span>,      <span class="comment">// 服务器开始响应请求</span></span><br><span class="line">responseEnd: <span class="number">1500979374540</span>,        <span class="comment">// 服务器可能会采用流式响应，或者分片传输。这个属性表示浏览器接收到完整页面的时刻</span></span><br><span class="line">domLoading: <span class="number">1500979374442</span>,        <span class="comment">// 开始解析 DOM, 此时 document.readyState 变成 loading</span></span><br><span class="line">domInteractive: <span class="number">1500979375806</span>,    <span class="comment">// DOM 树解析完成，此时 document.readyState 变成 interactive，可以在 JS 里面访问 DOM 了，但此时 JS 未必解析执行完毕了</span></span><br><span class="line">domContentLoadedEventStart: <span class="number">1500979375806</span>,    <span class="comment">// JS 也解析执行完了(不包括 async 加载的 JS)，触发 DOMContentLoaded 事件</span></span><br><span class="line">domContentLoadedEventEnd: <span class="number">1500979375827</span>,      <span class="comment">// DOMContentLoaded 事件结束</span></span><br><span class="line">domComplete: <span class="number">1500979376043</span>,                   <span class="comment">// 页面内资源全部加载完毕（比如图片、音视频），JS 解析完毕，此时 document.readyState 变为 complete</span></span><br><span class="line">loadEventStart: <span class="number">1500979376043</span>,    <span class="comment">// 触发 onload 事件</span></span><br><span class="line">loadEventEnd:<span class="number">1500979376049</span>        <span class="comment">// onload 事件结束</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>拿到这些节点的时间戳之后，各个阶段的耗时就能知道了 </p>
</blockquote>
<p><strong>当采样至一定的时间段后，点击暂停，浏览器会生成如下的图表</strong></p>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/performance.png" alt="performance"></p>
<ul>
<li>区域 1 是一个缩略图，可以看到除了时间轴以外被上下分成了四块，分别代表 <code>FPS</code>、<code>CPU</code> 时间、网络通信时间、堆栈占用。这个缩略图可以横向缩放，白色区域是下面可以看到的时间段</li>
<li>区域 2 可以看一些交互事件，例如你滚动了一下页面，那么这里会出现一个 <code>scroll</code> 的线段，线段覆盖的范围就是滚动经过的时间</li>
<li>区域 3 则是具体的事件列表了</li>
<li>区域 4 是概览</li>
</ul>
<blockquote>
<ul>
<li>一开始没有记录的时候，所有的区域都是空的。开始统计和结束统计都很简单，左上角那坨黑色的圆圈就是。它右边那个长得像“禁止通行”的按钮是用来清除现有记录的。当有数据的时候，我们把鼠标滚轮向上滚，可以看到区域被放大了</li>
<li>短短的时间里，浏览器做了这么多事情。对于一般的屏幕，原则上来说一秒要往屏幕上绘制<code>60</code> 帧，所以理论上讲我们一帧内的计算时间不能超过 <code>16</code> 毫秒</li>
</ul>
</blockquote>
<ul>
<li><p>不同的颜色表示不同的事件</p>
<ul>
<li>蓝色：网络通信和<code>HTML</code>解析</li>
<li>黄色：<code>JavaScript</code>执行</li>
<li>紫色：样式计算和布局，即重排</li>
<li>绿色：重绘</li>
</ul>
<blockquote>
<p>哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大</p>
</blockquote>
</li>
</ul>
<p><strong>查看页面的重绘过程</strong></p>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/render.png" alt="render"></p>
<p><strong>简单提一下什么是回流重绘</strong></p>
<ul>
<li>回流</li>
</ul>
<blockquote>
<p>当<code>render Tree</code>中的一部分或全部元素的规模尺寸、布局、隐藏等改变而需要重新构建，这称为回流（<code>reflow</code>）</p>
</blockquote>
<ul>
<li>重绘</li>
</ul>
<blockquote>
<p>当<code>render Tree</code>中的一些元素需要更新属性，而这些属性这是影响元素的风格，而不会影响布局的，比如<code>background-color</code>，则称为重绘（<code>repaint</code>）</p>
</blockquote>
<p>回流必定会引起重绘，重绘不一定引起回流。这也是我们在写页面的时候关注的一些细节点。</p>
<h3 id="4-3-前端存储能力"><a href="#4-3-前端存储能力" class="headerlink" title="4.3 前端存储能力"></a>4.3 前端存储能力</h3><h4 id="4-3-1-LocalStorage、SessionStorage"><a href="#4-3-1-LocalStorage、SessionStorage" class="headerlink" title="4.3.1 LocalStorage、SessionStorage"></a>4.3.1 LocalStorage、SessionStorage</h4><blockquote>
<p>客户端出于不同的原因，我们会存储一些相应的用户数据，如</p>
</blockquote>
<ul>
<li>在页面间共享数据——适用于同一个网站，页面间使用不同的框架</li>
<li>存储用户的 <code>token</code>——缓存在内存或者 <code>localstorage</code> 用于登录，在重要的操作时再验证权限</li>
<li>缓存数据，加快下次打开速度</li>
<li>临时保存用户未完成的表单</li>
<li>存储 <code>JavaScript</code> 代码，以加快打开速度</li>
</ul>
<blockquote>
<p>数据存储并不是一件很难的事。只需要</p>
</blockquote>
<ul>
<li>选择一个合适的存储介质</li>
<li>决定要存储的数据内容及形式</li>
<li>创建存储和读取接口</li>
</ul>
<p>我们只需要想一个 <code>key</code>，再想一个 <code>value</code> 就可以保存这个值了，如 <code>localStorge</code> 的<code>setItem</code> 和 <code>getItem</code> 就可以轻松达到这个要求了。而对于常用的数据格式来说，加上个 <code>JSON.stringify</code> 来转换对象为字符 串，从 <code>localStorage</code> 中读取数据时，再用 <code>JSON.parse</code> 去解析即可</p>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/local.png" alt="local"></p>
<h4 id="4-3-2-IndexDB"><a href="#4-3-2-IndexDB" class="headerlink" title="4.3.2 IndexDB"></a>4.3.2 IndexDB</h4><blockquote>
<p>对于 <code>IndexedDB</code> 来说，我们就可以使用对象来存储了</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/indexDB.jpg" alt="indexDB"></p>
<h4 id="4-3-3-Cookies"><a href="#4-3-3-Cookies" class="headerlink" title="4.3.3 Cookies"></a>4.3.3 Cookies</h4><p><strong>Cookie存储的限制</strong></p>
<ul>
<li>作为浏览器存储，大小<code>4KB</code>左右</li>
<li>需要设置过期时间，<code>expire</code></li>
<li><code>cookie</code>的存储能力被<code>localStorage</code>代替</li>
</ul>
<blockquote>
<p>非常重要的一点，<code>CDN</code>域名不要携带<code>cookie</code>，因为每次请求中都不需要用户信息，否则会浪费大量的流量</p>
</blockquote>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/cookie.png" alt="cookie"></p>
<h4 id="4-3-4-Service-worker-离线应用"><a href="#4-3-4-Service-worker-离线应用" class="headerlink" title="4.3.4 Service worker-离线应用"></a>4.3.4 Service worker-离线应用</h4><blockquote>
<p><code>service worker</code> 是一个脚本，独立于当前网页，将其在后台运行，为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性讲包括推送消息，背景后台同步，但它讲推出的第一个首页特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。</p>
</blockquote>
<p><strong>service worker的应用</strong></p>
<ul>
<li>使用拦截和处理网络请求的能力，去实现一个离线应用</li>
<li>使用<code>Service worker</code>在后台运行同时能和页面通信的能力</li>
</ul>
<p><strong>例子</strong></p>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/worker.png" alt="service-worker"></p>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/server-worker.png" alt="server-worker"></p>
<blockquote>
<p>不同的情况下，我们可需要在不同的存储介质中保持他们了，这个时候只需要不同的适配器即可。我们可以使用不同的库来，如支持使用不同介质的<code>localForge</code>，<code>IndexedDB</code>、<code>WebSQL</code>、<code>localStorage</code>。又或者是支持不同浏览器的 <code>store.js</code></p>
</blockquote>
<ul>
<li>在客户端上存储数据的时候，就那么几种情况</li>
<li>单条数据。主要用于存储一些简单的数据，如用户 <code>Token</code>、功能开关、临时数据等等。</li>
<li>一个模型的数据集合。</li>
<li>多个模型的数据集合。</li>
<li>复杂的地方就是处理这些数据模型</li>
</ul>
<h4 id="4-3-5-总结对比"><a href="#4-3-5-总结对比" class="headerlink" title="4.3.5 总结对比"></a>4.3.5 总结对比</h4><p><strong>Cookie</strong></p>
<ul>
<li>因为<code>HTTP</code>请求无状态，所以需要<code>cookie</code>去维护客户端状态</li>
<li>过期时间<code>expire</code></li>
<li><code>cookie</code>的生成方式<ul>
<li><code>http response header</code>中的<code>set-cookie</code></li>
<li>js中可以通过<code>document.cookie</code>读写<code>cookie</code><ul>
<li>仅仅作为浏览器存储（大小<code>4KB</code>左右）</li>
<li><code>cookie</code>中在相关域名下面—<code>cdn</code>的流量损耗</li>
<li><code>httpponly</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>LocalStorage</strong></p>
<ul>
<li><code>HTML5</code>设计出来专门用于浏览器存储的</li>
<li>大小为<code>5M</code>左右</li>
<li>仅仅在客户端使用，不和服务端进行通信</li>
<li>浏览器本地缓存的方案</li>
</ul>
<p><strong>SessionStorage</strong></p>
<ul>
<li>会话级别的浏览器存储</li>
<li>大小为<code>5M</code>左右</li>
<li>仅仅在客户端使用，不和服务端进行通信</li>
<li>对表单信息的维护</li>
</ul>
<h2 id="五、JS中的异步处理方案"><a href="#五、JS中的异步处理方案" class="headerlink" title="五、JS中的异步处理方案"></a>五、JS中的异步处理方案</h2><blockquote>
<ul>
<li>在<code>JavaScript</code>的世界中，所有代码都是单线程执行的</li>
<li>由于这个“缺陷”，导致<code>JavaScript</code>的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现</li>
<li>异步操作会在将来的某个时间点触发一个函数调用</li>
</ul>
</blockquote>
<ul>
<li>主流的异步处理方案主要有：回调函数(<code>CallBack</code>)、<code>Promise</code>、<code>Generator</code>函数、<code>async/await</code></li>
</ul>
<h3 id="5-1-回调函数-CallBack"><a href="#5-1-回调函数-CallBack" class="headerlink" title="5.1 回调函数(CallBack)"></a>5.1 回调函数(CallBack)</h3><ul>
<li>这是异步编程最基本的方法</li>
<li>假设我们有一个<code>getData</code> 方法，用于异步获取数据，第一个参数为请求的 <code>url</code> 地址，第二个参数是回调函数，如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">url, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟发送网络请求</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 假设 res 就是返回的数据</span></span><br><span class="line">        <span class="keyword">var</span> res = &#123;</span><br><span class="line">            url: url,</span><br><span class="line">            data: <span class="built_in">Math</span>.random()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行回调，将数据作为参数传递</span></span><br><span class="line">        callBack(res)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们预先设定一个场景，假设我们要请求三次服务器，每一次的请求依赖上一次请求的结果，如下</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getData(<span class="string">'/page/1?param=123'</span>, (res1) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    getData(<span class="string">`/page/2?param=<span class="subst">$&#123;res1.data&#125;</span>`</span>, (res2) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res2)</span><br><span class="line">        getData(<span class="string">`/page/3?param=<span class="subst">$&#123;res2.data&#125;</span>`</span>, (res3) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res3)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过上面的代码可以看出，第一次请求的 <code>url</code> 地址为：<code>/page/1?param=123</code>，返回结果为 <code>res1</code></li>
<li>第二个请求的 <code>url</code> 地址为：<code>/page/2?param=${res1.data}</code>，依赖第一次请求的<code>res1.data</code>，返回结果为<code>res2</code>。</li>
<li>第三次请求的 <code>url</code>地址为：<code>/page/3?param=${res2.data}</code>，依赖第二次请求的<code>res2.data</code>，返回结果为 <code>res3</code></li>
<li>由于后续请求依赖前一个请求的结果，所以我们只能把下一次请求写到上一次请求的回调函数内部，这样就形成了常说的：<strong>回调地狱</strong></li>
</ul>
<h3 id="5-2-Promise"><a href="#5-2-Promise" class="headerlink" title="5.2 Promise"></a>5.2 Promise</h3><ul>
<li><code>Promise</code> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大</li>
<li>简单说，它的思想是，每一个异步任务返回一个<code>Promise</code>对象，该对象有一个<code>then</code>方法，允许指定回调函数</li>
<li>现在我们使用 <code>Promise</code> 重新实现上面的案例，首先，我们要把异步请求数据的方法封装成 <code>Promise</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataAsync</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: <span class="built_in">Math</span>.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么请求的代码应该这样写</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getDataAsync(<span class="string">'/page/1?param=123'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res1)</span><br><span class="line">        <span class="keyword">return</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res1.data&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res2)</span><br><span class="line">        <span class="keyword">return</span> getDataAsync(<span class="string">`/page/3?param=<span class="subst">$&#123;res2.data&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res3</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res3)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>then</code> 方法返回一个新的 <code>Promise</code> 对象，<code>then</code> 方法的链式调用避免了 <code>CallBack</code> 回调地狱</li>
<li>但也并不是完美，比如我们要添加很多 <code>then</code> 语句， 每一个 <code>then</code> 还是要写一个回调</li>
<li>如果场景再复杂一点，比如后边的每一个请求依赖前面所有请求的结果，而不仅仅依赖上一次请求的结果，那会更复杂。 为了做的更好，<code>async/await</code> 就应运而生了，来看看使用 <code>async/await</code> 要如何实现</li>
</ul>
<h3 id="5-3-Async-Await"><a href="#5-3-Async-Await" class="headerlink" title="5.3 Async/Await"></a>5.3 Async/Await</h3><blockquote>
<p>这是异步的终极解决方案，我们看一下用这种方式写异步有什么变化</p>
</blockquote>
<ul>
<li><code>await</code>后面必须是一个<code>Promise</code>对象</li>
<li><code>getDataAsync</code> 方法不变，如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataAsync</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: <span class="built_in">Math</span>.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接着在调用的函数外层加上<code>async</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res1 = <span class="keyword">await</span> getDataAsync(<span class="string">'/page/1?param=123'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">var</span> res2 = <span class="keyword">await</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res1.data&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">    <span class="keyword">var</span> res3 = <span class="keyword">await</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res2.data&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到使用<code>async\await</code>就像写同步代码一样</li>
<li>对比 <code>Promise</code> 是不是非常清晰，但是 <code>async/await</code> 是基于 <code>Promise</code> 的，因为使用 <code>async</code> 修饰的方法最终返回一个 <code>Promise</code>， 实际上，<code>async/await</code> 可以看做是使用 <code>Generator</code> 函数处理异步的语法糖</li>
</ul>

      
    </div>
    
	
		<! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   欣赏此文?求鼓励,求支持！
        </span>
        <br>
    </div>  
	<div id="donate_guide" class="donate_bar center hidden" >
		<!-- 支付宝打赏图案 -->
		<img src="/img/zhifubao.jpg" alt="支付宝打赏"> 
		<!-- 微信打赏图案 -->
		<img src="/img/weixin.jpg" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</div>
<! -- 添加捐赠图标 -->
    
	
	
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/10/time-manage/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          时间效率管理
        
      </div>
    </a>
  
  
    <a href="/2018/01/24/心中所念皆文学/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">心中所念皆文学-阅读体会</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2073284" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="tech-share-summary" data-title="年终技术分享总结" data-url="http://life.poetries.top/2018/02/03/tech-share-summary/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"poetry"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Poetry
    	</div>
		<p style="text-align:left;text-indent:10px;"><script type="text/javascript" src="http://tajs.qq.com/stats?sId=59154049" charset="UTF-8"></script></p>
      	<div class="footer-right">
      		<a  target="_blank">Hexo</a>  Theme <a  target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div>
	<a href="javascript:;" id="totop" title="回到顶部"></a> 
</div>
<script src="/js/totop.js"></script>

  </div>
</body>
</html>